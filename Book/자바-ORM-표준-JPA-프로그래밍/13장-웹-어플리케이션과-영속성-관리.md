# 13장 웹 어플리케이션과 영속성 관리

- [13.1 트랜잭션 범위의 영속성 컨텍스트](#131-트랜잭션-범위의-영속성-컨텍스트)
- [13.2 준영속 상태와 지연 로딩](#132-준영속-상태와-지연-로딩)
- [13.3 OSIV](#133-osiv)
- [13.4 너무 엄격한 계층](#134-너무-엄격한-계층)
- [13.5 정리](#135-정리)

---

스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 트랜잭션과 영속성 컨텍스트를 관리해주므로 어플리케이션을 손쉽게 개발할 수 있다. 하지만 JPA의 내부 동작을 이해하지 못하면 문제가 발생했을 때 해결하기 쉽지 않다.

이번 장을 통해 컨테이너 환경에서 JPA가 동작하는 내부 동작 방식을 이해하고, 컨테이너 환경에서 웹 어플리케이션을 개발할 때 발생할 수 있는 다양한 문제점과 해결 방안 알아보기!

## 13.1 트랜잭션 범위의 영속성 컨텍스트
순수하게 J2SE(Java 2 Standard Edition) 환경에서 JPA를 사용하면 개발자가 직접 엔티티 매니저를 생성하고 트랜잭션도 관리해야 한다. 하지만 스프링이나 J2EE(Java 2 Enterprise Edition) 컨테이너 환경에서 JPA를 사용하면 커테이너가 제공하는 전략을 따라야 한다. 

### 13.1.1 스프링 컨테이너의 기본 전략
![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/6deade9d-6309-4ff0-b6e0-aff28cd43d26)

스프링 컨테이너는 **트랜잭션 범위의 영속성 컨텍스트**를 기본 전략으로 사용한다. 이 전략은 [트랜잭션의 범위 = 영속성 컨텍스트의 생존 범위]인 것이다. <br>
즉, 트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고, 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다. 그리고 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

스프링 프레임워크를 사용하면 보통 비즈니스 로직을 시작하는 *서비스* 계층에서 `@Transactional` 어노테이션을 선언해 트랜잭션을 시작한다. 호출한 메소드를 실행하기 전 **스프링의 트랜잭션 AOP**가 먼저 동작한다.

![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/7ca96011-2aa0-45d2-881c-6bbfece6125f)

**스프링 트랜잭션 AOP**는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하고, 대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다. 이 때 트랜잭션을 커밋하면 JPA는 먼저 영속성 컨텍스트를 플러시해서 변경사항을 데이터베이스에 반영한 후에 데이터베이스 트랜잭션을 커밋한다. 만약 예외가 발생하면 트랜잭션을 롤백하고 종료하는데, 이 때는 플러시를 호출하지 않는다.

### 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.
![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/cd044b37-684f-4c94-8dc2-17c5d0b7097a)

다른 레포지토리여도 `@Transactional`을 선언한 서비스에서 같이 호출되었다면 같은 트랜잭션 범위에 있으므로, 같은 영속성 컨텍스트를 사용한다.

### 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.
![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/40c3c5c7-60de-4dda-90d3-becce7aafd46)

여러 스레드에서 동시에 요청이 와 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.<br>
스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 따라서 같은 엔티티 매니저를 호출해도 접근하는 영속성 컨텍스트가 다르므로 멀티스레드 환경에서 안전하다.

스프링이나 J2EE 컨테이너의 가장 큰 장점은 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다는 점이다. 따라서 개발자는 싱글 스레드 어플리케이션처럼 단순하게 개발할 수 있고 결과적으로 비즈니스 로직 개발에 집중할 수 있다.

## 13.2 준영속 상태와 지연 로딩
트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료된다. 따라서 조회한 엔티티가 컨트롤러나 뷰 같은 *프리젠테이션 계층*에서는 *준영속 상태*가 된다.<br>
따라서 프리젠테이션 계층인 컨트롤러에선 변경 감지와 지연 로딩이 동작하지 않는다.

### 준영속 상태와 변경 감지
단순히 데이터를 보여주는 프리젠테이션 계층에서는 데이터를 수정할 일이 거의 없다. 오히려 변경 감지 기능이 프리젠테이션 계층에서도 동작하면, 어플리케이션 계층이 가지는 책임이 모호해지고 데이터를 어디서 어떻게 변경했는지 프리젠테이션 계층까지 다 찾아야하므로 어플리케이션 유지 보수가 어렵다. <br>
따라서 프리젠테이션 계층에서는 데이터 변경 로직이 없어야하며, 변경 감지가 일어나지 않는 것이 문제되지 않는다.

### 준영속 상태와 지연 로딩
뷰를 렌더링할 때 연관된 엔티티도 함께 사용해야 하는데, 연관된 엔티티를 지연 로딩으로 설정한 다음 초기화하지 않고 실제 데이터를 불러오려고 하면 지연 로딩을 할 수 없다. 만약 하이버네이트를 구현체로 사용하면 `org.hibernate.LazyInitializationException` 예외가 발생한다.

준영속 상태의 지연 로딩을 해결하는 방법은 크게 2가지가 있다.
* 뷰가 필요한 엔티티를 **미리 로딩**해두는 방법
* **OSIV**를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법

뷰가 필요한 엔티티를 미리 다 로딩해서 지연 로딩이 발생하지 않도록 하는 3가지의 방법이 있다.
* 글로벌 페치 전략 수정
* JPQL 페치 조인
* 강제로 초기화

### 13.2.1 글로벌 페치 전략 수정
가장 간단하게는 글로벌 페치 전략을 지연 로딩에서 즉시 로딩으로 변경하면 된다.

이 경우에 단점 2가지
1. 사용하지 않는 엔티티를 로딩한다.
    * 예를 들어, 화면 A에선 `Order`와 `Member` 둘 다 필요해 글로벌 페치 전략을 즉시 로딩으로 설정했다. 그러나 화면 B에선 `Order` 엔티티만 있으면 충분하다. 하지만 즉시 로딩 전략으로 인해 `Member` 엔티티 역시 함께 조회된다.
2. N+1 문제가 발생한다.
    * JPA를 사용하면서 성능 상 가장 조심해야 하는 것이 바로 **N+1 문제**다. <br>
        즉시 로딩으로 설정한 경우 `em.find()`로 엔티티를 조회한다면 JOIN 쿼리로 함께 조회한다.<Br>
        그러나 JPQL을 사용하는 경우 문제가 발생한다. JPA가 JPQL을 분석해서 SQL을 생성할 때는 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용한다. 따라서 즉시 로딩이든 지연 로딩이든 구분하지 않고 JPQL 쿼리 자체에 충실하게 SQL을 만든다.

### 13.2.2 JPQL 페치 조인
글로벌 페치 전략을 수정할 때 발생할 수 있는 N+1문제는 JPQL 페치 조인으로 해결할 수 있다.<br>
페치 조인을 사용하면 SQL JOIN을 사용해서 페치 조인 대상까지 함께 조회한다. 따라서 연관된 엔티티를 이미 로딩했으므로 글로벌 페치 전략은 무의미하다.

### 페치 조인의 단점
무분별하게 사용하면 화면에 맞춘 리포지토리 메소드의 수가 증가할 수 있다. 결국 프리젠테이션 계층이 알게모르게 데이터 접근 계층을 침범하는 것이다.<br>
각 화면에 맞는 메소드를 만들고 호출하면 최적화는 할 수 있지만, 뷰와 리포지토리 간에 논리적 의존관계가 발생한다.

다른 대안으로는 `repository.findOrder()` 하나만 만들고 여기서 페치 조인으로 `Order`, `Member`를 함께 로딩하는 것이다. `Order` 엔티티만 필요한 화면은 약간의 로딩 시간이 증가하겠지만 페치 조인은 JOIN을 사용해서 쿼리 한 번으로 필요한 데이터를 조회하므로 성능에 미치는 영향은 미비하다.(물론 상황에 따라 다르다.)<br> 
무분별한 최적화로 프리젠테이션 계층과 데이터 접근 계층 간에 의존관계가 급격하게 증가하는 것보다는 적절한 선에서 타협점을 찾는 것이 합리적이다.

(+) 일단 가능한 통일된 메소드를 사용하고, 추후 병목 지점으로 확인이 된다면 새로운 메소드를 생성해서 최적화를 진행하는 것이 좋은 방법이겠다! 이런 경우와 유사하게, 먼저 통일되고 단순하여 관리하기 좋은 방식으로 개발하고 성능 테스트를 거치며 최적화를 하는 흐름이 좋겠다.

### 13.2.3 강제로 초기화
강제로 초기화하기는 영속성 컨텍스트가 살아있을 때 프리젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법이다.

서비스 내에서 `order.getMember().getName()`과 같은 코드를 더해 강제로 초기화한다.<br>
`order.getMember()`까지만 호출하면 단순히 프록시 객체만 반환하고 초기화되지 않는다.

JPA 표준에는 강제로 초기화하는 메소드는 없고 초기화 여부를 확인할 수만 있으며, 하이버네이트를 사용하면 `initialize()` 메소드로 프록시를 강제 초기화할 수 있다.

그렇지만 서비스 계층이 프리젠테이션 계층을 위한 일까지 하는 것은 좋지 않다. 따라서 이 역할을 **FACADE 계층**이 담당한다.

### 13.2.3 FACADE 계층 추가
![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/e36466d2-e96c-4d04-9c09-efc39c08fc56)

프리젠테이션 계층과 서비스 계층 사이에 FACADE 계층을 하나 더 두는 방법이다. 뷰를 위한 프록시 초기화는 이곳에서 담당한다. <br>
프록시를 초기화하려면 영속성 컨텍스트가 필요하므로 FACADE 계층에서 트랜잭션을 시작해야 한다.

### FACADE 계층의 역할과 특징
* 프리젠테이션 계층과 도메인 모델 계층 간의 **논리적 의존성을 분리**해준다.
* 프리젠테이션 계층에서 필요한 **프록시 객체를 초기화**한다.
* **서비스 계층을 호출**해서 비즈니스 로직을 실행한다.
* 리포지토리를 직접 호출해 뷰가 요구하는 엔티티를 찾는다.

단점으로는 중간 계층이 하나 더 끼어든다는 점으로, 결국 더 많은 코드를 작성해야 한다는 점이다. 그리고 FACADE 계층에는 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많을 것이다. 

### 13.2.5 준영속 상태와 지연 로딩의 문제점
뷰를 개발할 때 필요한 엔티티를 미리 초기화하는 방법은 생각보다 오류가 발생할 가능성이 높다.

결국 모든 문제는 엔티티가 프리젠테이션 계층에서 준영속 상태이기 때문이다. <br>
영속성 컨텍스트를 뷰까지 살아있게 열어두자. 그러면 뷰에서도 지연 로딩을 사용할 수 있는데 이것이 **OSIV**이다.

## 13.3 OSIV
**OSIV**(Open Session In View)는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다.

### 13.3.1 과거 OSIV: 요청 당 트랜잭션
![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/ee140651-89cc-46af-ab9d-c363a916c585)

OSIV의 핵심은 뷰에서도 지연 로딩이 가능하도록 하는 것이다. 가장 단순한 구연 방법은 클라이언트의 **요청이 들어오자마자** 서블릿 필터나 스프링 인터셉터에서 **트랜잭션을 시작**하고, 요청이 끝날 때 트랜잭션도 끝내는 것이다. 이것을 **요청 당 트랜잭션 방식의 OSIV**라고 한다.

### 요청 당 트랜잭션 방식의 OSIV의 문제점
문제점은 컨트롤러나 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있다는 점이다. 예를 들어 보안상의 이유로 고객 이름을 XXX로 변경해서 출력해야 한다고 가정하자.
```java
class MemberController {
    public String viewMember(Long id) {
        Member member = memberService.getMember(id);
        member.setName("XXX");
        model.addAttribute("member", member);
        ...
    }
}
```

개발자는 단순히 뷰에 노출할 때만 고객 이름을 XXX로 변경하고 싶은 것이지만, 요청 당 트랜잭션 방식의 OSIV는 뷰를 렌더링한 후에 트랜잭션을 커밋한다. 

이런 문제를 해결하려면 프리젠테이션 계층에서 엔티티를 수정할 수 없도록 막으면 된다. 그 방법으로는,
* 엔티티를 읽기 전용 인터페이스로 제공
* 엔티티 래핑
* DTO만 반환

**엔티티를 읽기 전용 인터페이스로 제공**
```java
interface MemberView {
    public String getName();
}

@Entity
class Member implements MemberView {
    ...
}

class MemberService {
    public MemberView getMember(id) {
            return memberRepository.findById(id);
    }
}
```
프리젠테이션 계층에는 `Member` 엔티티 대신에 회원 엔티티의 읽기 전용 메소드만 있는 `MemberView` 인터페이스를 제공했다.

**엔티티 래핑**
```java
class MemberWrapper {
    private Member member;

    public MemberWrapper(member) {
        this.member = member;
    }

    // 읽기 전용 메소드만 제공
    public String getName() {
        member.getName();
    }
}
```
`Member` 엔티티가 감싸고 있는 `MemberWrapper` 객체를 만들었다. 이 객체는 `Member` 엔티티의 읽기 메소드만 제공한다.

**DTO만 반환**

가장 전통적인 방법으로 프리젠테이션 계층에 엔티티 대신에 단순히 데이터만 전달하는 객체인 **DTO**를 생성해서 반환하는 것이다. 하지만 이 방법은 OSIV를 사용하는 장점을 살릴 수 없으며 엔티티를 거의 복사한 듯한 DTO 클래스도 하나 더 만들어야 한다는 단점이 있다.

설명한 세 방법이 모두 코드량이 상당히 증가한다는 단점이 있다. 이 방식은 최근에 거의 사용하지 않는다.

### 13.3.2 스프링 OSIV: 비즈니스 계층 트랜잭션
### 스프링 프레임워크가 제공하는 OSIV 라이브러리
스프링 프레임워크의 `spring-orm.jar`는 다양한 OSIV 클래스를 제공한다. OSIV를 서블릿 필터에서 적용할 지 스프링 인터셉터에서 적용할 지에 따라 원하는 클래스를 선택해서 사용하면 된다.

* **하이버네이트 OSIV 서블릿 필터**: `org.springframework.orm.hibernate4.support.OpenSessionInViewFilter`
* **하이버네이트 OSIV 스프링 인터셉터**: `org.springframework.orm.hibernate4.support.OpenSessionInViewInterceptor`
* **JPA OEIV 서블릿 필터**: `org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter`
* **JPA OEIV 서블릿 필터**: `org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor`

예를 들어 JPA를 사용하면서 서블릿 필터에 OSIV를 적용하려면 `OpenEntityManagerInViewFilter`를 서블릿 필터에 등록하면 되고, 스프링 인터셉터에 OSIV를 적용하려면 `OpenEntityManagerInViewInterceptor`를 스프링 인터셉터에 등록하면 된다.

### 스프링 OSIV 분석 
스프링 프레임워크가 제공하는 OSIV는 **비즈니스 계층에서 트랜잭션을 사용하는 OSIV**다. 이름 그대로 OSIV를 사용하기는 하지만 트랜잭션은 비즈니스 계층에서만 사용한다는 뜻이다.

![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/56ae7dc0-4671-4a70-a2f8-60fc86eac302)

**동작 원리**

1. 클라이언트의 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 **영속성 컨텍스트를 생성**한다. 이때 트랜잭션은 시작하지 않는다.
2. 서비스 계층에서 `@Transactional`로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와 **트랜잭션을 시작**한다.
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 때 트랜잭션은 끝내지만 **영속성 컨텍스트는 종료하지 않는다**.
4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 **영속 상태를 유지**한다.
5. 서블릿 필터나 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료하는데, 플러시를 호출하지 않는다.

### 트랜잭션 없이 읽기
영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다. 엔티티를 단순히 조회만 할때는 트랜잭션이 없어도 되는데 이것을 **트랜잭션 없이 읽기**라 한다. 프록시를 초기화하는 지연 로딩도 조회 기능이므로 트랜잭션 없이 읽기가 가능하다. 

스프링이 제공하는 OSIV를 사용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다. 그리고 트랜잭션 없이 읽기를 사용해서 프리젠테이션 계층에서 지연 로딩 기능을 사용할 수 있다.

프리젠테이션 계층에서 Setter 함수가 호출되어도 플러시가 동작하지 않는 이유는 2가지이다.
* 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하려면 영속성 컨텍스트를 **플러시**해야한다. 하지만 스프링이 제공하는 OSIV는 요청이 끝나면 플러시를 호출하지 않고 `em.close()`로 영속성 컨텍스트만 종료해버리므로 플러시가 일어나지 않는다.
* 프리젠테이션 계층에서 `em.flush()`를 호출해서 강제로 플러시해도 예외가 발생한다.

### 스프링 OSIV 주의사항
프리젠테이션 계층에서 *엔티티를 수정한 직후*에 *트랜잭션을 시작하는 서비스 계층을 호출*하면 문제가 발생한다.

![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/5de2003a-f599-49b1-bfb2-756739be7949)

1. 컨트롤러에서 회원 엔티티를 조회하고 이름을 수정했다.
2. `biz()` 메소드를 실행해서 트랜잭션이 있는 비즈니스 로직을 실행했다.
3. 트랜잭션 AOP가 동작하면서 영속성 컨텍스트에 트랜잭션을 시작한다. 그리고 `biz()` 메소드를 실행한다.
4. `biz()` 메소드가 끝나면 트랜잭션 AOP는 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 때 변경 감지가 동작하면서 1번에서 수정했던 수정 사항이 데이터베이스에 반영된다.

문제를 해결하는 단순한 방법은 트랜잭션이 있는 비즈니스 로직을 **모두** 호출하고 나서 엔티티를 변경하면 된다. <br>
스프링 OSIV는 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있으므로 이런 문제가 발생한다.

### 13.3.3 OSIV 정리
### 스프링 OSIV의 특징
* OSIV는 클라이언트의 요정이 들어오는 시점에 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 유지한다.
* 엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다. 트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 *조회*만 할 수 있다.

### 스프링 OSIV의 단점
* OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다는 점을 주의해야 한다. 특히 트랜잭션 롤백 시 주의해야 한다. (이후 구체적으로 나온다.)
* 프리젠테이션 계층에서 엔티티를 수정하고나서 비즈니스 로직을 수행하면 해당 수정 사항이 반영될 수 있다.
* 프리젠테이션 계층에서 지연 로딩에 의한 SQL이 실행된다. 따라서 성능 튜닝 시에 확인해야할 부분이 넓다.

### OSIV vs FASCADE vs DTO
OSIV를 사용하지 않는 대안은 결국 준영속 상태가 되기 전에 프록시를 초기화하는 방법이다.

### OSIV를 사용하는 방법이 만능은 아니다.
복잡한 화면을 구성할 때는 엔티티로 조회하기보다는 처음부터 통계 데이터를 구상하기 위한 JPQL을 작성해서 DTO로 조회하는 것이 효과적이다. 그리고 수많은 테이블을 조인해서 보여주어야 하는 복잡한 관리자 화면도 JPQL로 필요한 데이터들만 조회해서 DTO로 반환하는 것이 더 나은 해결책일 수 있다.

### OSIV는 같은 JVM을 벗어난 원격 상황에서는 사용할 수 없다.
예를 들어 JSON이나 XML을 생성할 때는 지연 로딩을 사용할 수 있지만, 원격지인 클라이언트에서 연관된 엔티티를 지연 로딩하는 것은 불가능하다.

* 외부 API: 외부에 노출한다. 한 번 정의하면 변경이 어렵다. (ex 다른 팀과 협업하기 위한 API, 타 기업과 협업하는 API)
* 내부 API: 외부에 노출하지 않는다. 언제든지 변경할 수 있다. (ex 같은 프로젝트에 있는 화면을 구성하기 위한 AJAX 호출)

엔티티는 생각보다 자주 변경된다. 엔티티를 JSON 변환 대상 객체로 사용하면 엔티티를 변경할 때 노출하는 JSON API도 함께 변경횐다. 따라서 외부 API는 엔티티를 직접 노출하기보다는 엔티티를 변경해도 완충 역할을 할 수 있는 DTO로 변환해서 노출하는 것이 안전하다. 내부 API는 실용적 관점에서 엔티티를 직접 노출하는 방법도 괜찮을 수 있다.

## 13.4 너무 엄격한 계층
OSIV를 사용하면 영속성 컨텍스트가 프리젠테이션 계층까지 살아있으므로 미리 초기화할 필요가 없다. 따라서 단순한 엔티티 조회는 컨트롤러에서 리포지토리를 직접 호출해도 아무 문제가 없다.

## 13.5 정리
트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 동일한 경우 프리젠테이션 계층에서 지연 로딩을 할 수 없다는 단점이 있었다. OSIV를 사용하여 이 문제를 해결할 수 있다.
