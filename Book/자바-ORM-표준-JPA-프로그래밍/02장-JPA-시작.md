# 02장 JPA 시작
* [2.4 객체 매핑 시작](#24-객체-매핑-시작)
* [2.6 어플리케이션 개발](#26-어플리케이션-개발)

## 2.4 객체 매핑 시작
### 매핑 어노테이션
* `@Entity`<br>
해당 **클래스**를 **테이블과 매핑**한다고 JPA에게 선언
* `@Table`<br>
엔티티 클래스와 **매핑할 테이블 정보** 지정<br>
해당 어노테이션을 생략하면 클래스 이름을 테이블 이름으로 매핑한다.(정확히는 엔티티 이름을 사용한다.)
* `@Id`
* `@Column`
* 매핑 정보가 없는 필드<br>
매핑 어노테이션을 생략하면 필드 명을 사용하여 컬럼명으로 매핑<br>
대소문자 구분은 데이터베이스에 따라 다르다!

### 데이터베이스 방언
SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 JPA에서는 **방언**(Dialect)라고 한다.

## 2.6 어플리케이션 개발

### 2.6.1 엔티티 매니저 설정
### 엔티티 매니저 팩토리 생성
JPA를 시작하려면 `persistence.xml`의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야 한다.
```java
EntityManagerFactory emf = Persitence.createEntityManagerFactory("jpabook");
```
해당 코드를 통해 `META-INF/persistence.xml`에서 이름이 `jpabook`인 영속성 유닛을 찾아 엔티티 매니저 팩토리를 생성한다.

`persistence.xml`의 설정 정보를 읽어 JPA를 동작시키기 위한 기반 객체를 만들고 JPA 구현체에 따라서는 데이터베이스 커넥션 풀도 생성하므로, 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다.<br>
따라서 엔티티 매니저 팩토리는 어플리케이션 전체에서 **딱 한번만 생성**하고 **공유해서 사용**해야 한다.

### 엔티티 매니저 생성
```java
EntityManager em = emf.createEntityManager();
```
생성한 엔티티 매니저 팩토리를 통해 엔티티 매니저를 생성한다.

엔티티 매니저를 사용해서 엔티티를 데이터베이스에 **등록/수정/삭제/조회**할 수 있다. 엔티티 매니저는 내부에 데이터베이스 커넥션을 유지하면서 데이터베이스와 통신한다. 이처럼 데이터베이스 커넥션과 밀접환 관계가 있으므로 스레드 간에 공유하거나 재사용해서는 안된다.

### 2.6.3 비즈니스 로직 - 수정
```java
mgmber.setAge(20);
```
영속 상태의 엔티티를 수정하면 `em.update()`같은 메소드 호출 없이 수정이 반영된다.

### 2.6.4 JPQL
```java
// 하나 이상의 회원 목록을 조회하는 코드
TypedQuery<Member> query = 
		em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```
JPA는 **엔티티 객체 중심**으로 개발하므로, 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다.<br>
테이블이 아니라 엔티티 객체를 대상으로 검색하려면, 데이터베이스의 모든 데이터를 어플리케이션으로 불러와서 엔티티 객체로 변환 후 검색을 진행해야 하는데 이는 사실상 불가능하다.<br>
따라서 어플리케이션에서 필요한 데이터만 추출하기 위해선 SQL을 사용해야하는데, 이 때 JPA는 **JPQL**이라는 SQL을 추상화한 객체지향 쿼리 언어를 사용한다. 