# 08장 프록시와 연관관계 관리

* [8.1 프록시](#81-프록시)
* [8.2 즉시 로딩과 지연 로딩](#82-즉시-로딩과-지연-로딩)
* [8.3 지연 로딩 활용](#83-지연-로딩-활용)
* [8.4 영속성 전이: CASCADE](#84-영속성-전이-cascade)
* [8.5 고아 객체](#85-고아-객체)
* [8.6 영속성 전이 + 고아 객체, 생명 주기](#86-영속성-전이--고아-객체-생명-주기)

---

* 프록시와 즉시 로딩, 지연 로딩
    * 객체가 객체 그래프로 연관 그래프를 마음껏 탐색하기 위해 JPA 구현체들이 **프록시**라는 기술을 사용한다.
    * 처음부터 조회하는 것이 아닌, 사용하는 시점에서 데이터베이스에 조회한다.
* 영속성 전이와 고아 객체
    * 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이
    * 고아 객체 제거

## 8.1 프록시
엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이 것을 **지연 로딩**이라 한다.<br>
지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이 것을 **프록시 객체**라 한다.

### 8.1.1 프록시 기초
`EntityManager.find()`를 사용하면, 영속성 컨텍스트에 엔티티가 없을 때 데이터베이스를 조회한다.<br>
`EntityManager.getReference()`를 사용하면, 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미룰 수 있다.

### 프록시 객체의 초기화
프록시 객체는 타겟 객체를 실제로 사용할 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데, 이 것을 **프록시 객체의 초기화**라 한다.

![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/96e47dff-4d9a-431f-9754-78de8ba3150f)

```java
class MemberProxy extends Member {
    Member target = null;

    public String getName() {
        if (target == null) {
            // 2. 초기화 요청
            // 3. DB 조회
            // 4. 실제 엔티티 생성 및 참조 보관
            this.target = ...;
        }

        // 5. 실제 엔티티의 메소드 호출
        return target.getName();
    }
}
```

### 프록시 특징 
프록시 클래스는 실제 클래스를 상속받아 만들어지기 때문에 실제 클래스와 **겉 모양이 같다**. 따라서 이것이 진짜 객체인지 프록시 객체인지 구분할 필요가 없다.

![image](https://github.com/rhyun9584/Today-I-Learned/assets/45452033/fb2b7060-ae9a-4d84-afab-d2a24380b19e)

프록시 객체는 **실제 객체에 대한 참조**를 보관한다. 그리고 프록시 객체의 메소드를 호출하면 프록시는 **실제 객체의 메소드를 호출**한다.
* 처음 사용할 때 한 번만 초기화된다.
* 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것이 아니다.
* 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.
* 영속성 컨텍스트에 이미 엔티티가 존재한다면 `em.getReference()`를 호출해도 실제 엔티티가 반환된다.
* 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 준영속 상태의 프록시를 초기화할 수 없다.

### 8.1.2 프록시와 식별자
엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다. 따라서 `team.getId()`처럼 식별자를 가져오는 getter 메소드 호출은 프록시 객체를 초기화하지 않는다.

단, 엔티티 접근 방식을 필드(`@Access(AccessType.FILED)`)로 설정하면 JPA는 `team.getId()` 메소드가 `id`만 조회하는지, 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 구분할 수 없으므로 프록시 객체를 초기화한다.

```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1");
member.setTeam(team);
```

예시 같은 코드로 연관관계를 설정할 때, `Team` 엔티티를 데이터베이스에서 조회하지 않고 연관관계 설정이 가능하다. 

### 8.1.3 프록시 확인
JPA에서 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 알 수 있다

### 프록시 강제 초기화
하이버네이트의 `initialize()` 메소드를 사요하면 프록시를 강제로 초기화할 수 있다.

## 8.2 즉시 로딩과 지연 로딩
### 8.2.1 즉시 로딩 (EAGER LOADING)
엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.<br>
`@ManyToOne(fetch = FetchType.EAGER)` 어노테이션으로 설정

대부분의 JPA 구현체는 **즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용**한다.

### `NULL` 제약조건과 JPA 조인 전략
즉시 로딩을 위해 조인을 사용할 때, 외래 키 컬럼이 `NULL` 값을 허용하고있다면 JPA는 연관관계가 이어지지 않은 객체도 불러오기 위해 **LEFT OUTER JOIN**을 활용한다.<br>
그러나 외부 조인보다 내부 조인이 *성능*과 *최적화*에서 더 유리하다. 따라서 외래 키에 NOT NULL 제약조건을 설정하여 값이 있는 것을 보장해주어야 한다.<br>
`@JoinColumn`에 `nullable=false`를 설정하여 외래 키가 `NULL` 값을 허용하지 않는다고 알려주면, JPA는 외부 조인 대신 **내부 조인**을 사용한다.

### 8.2.2 지연 로딩 (LAZY LOADING)
`@ManyToOne(fetch = FetchType.LAZY)` <br>
실제 데이터가 필요한 순간이 되어서야 데이터베이스르 조회해서 프록시 객체를 초기화한다.

### 8.2.3 즉시 로딩, 지연 로딩 정리
대부분의 어플리케이션 로직에서 연관된 두 엔티티를 한 번에 조회한다면 **즉시 로딩**이 더욱 효율적이다.

## 8.3 지연 로딩 활용 
### 8.3.1 프록시와 컬렉션 래퍼
하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데, 이것을 **컬렉션 래퍼**라 한다.

엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만, 컬렉션은 컬랙션 래퍼가 지연 로딩을 처리해준다. 컬렉션 래퍼 역시 프록시의 역할을 한다.

### 8.3.2 JPA의 기본 fetch 전략
* `@ManyToOne`, `@OneToMany`: 즉시 로딩
* `@OneToMany`, `@ManyToMany`: 지연 로딩

기본으로는 연관된 엔티티가 하나면 *즉시 로딩*, 컬렉션이면 *지연 로딩*을 사용한다. 

추천하는 방법은 **모든 연관관계에 지연 로딩을 적용**하고, 개발이 어느 정도 완료 단계에 도달했을 때 실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화하면 된다.

### 8.3.3 `FetchType.EAGER` 사용 시 주의점
* 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.
* 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.

## 8.4 영속성 전이: CASCADE
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 **영속성 전이** 기능을 사용하면 된다.

### 8.4.1 영속성 전이: 저장
```java
@Entity
public class Parent {
    ...
    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
    private List<Child> children = new ArrayList<>();
    ...
}
```
`CascadeType.PERSIST`로 설정하면 `Parent`만 영속화해도 연결된 `Child` 엔티티까지 한 번에 영속화된다.

### 8.4.2 영속성 전이: 삭제
`CascadeType.REMOVE`로 설정하면 부모 엔티티를 삭제할 때 자식 엔티티도 한 번에 삭제된다.<br>
만약 영속성 전이 설정 없이 부모 엔티티만을 삭제하면 데이터베이스에서 외래 키 무결성 예외가 발생한다.

### 8.4.3 CASCADE의 종류
```java
public enum CascadeType {
    ALL,        // 모두 적용
    PERSIST,    // 영속
    MERGE,      // 병합
    REMOVE,     // 삭제
    REFRESH,
    DETACH
}
```
`cascade = {CascadeType.PERSIST, CascadeType.REMOVE}`처럼 여러 속성을 같이 사용할 수 있다.

## 8.5 고아 객체
JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 **고아 객체 제거**라 한다.

부모 엔티티 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.
```java
@Entity
public class Parent {
    ...
    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<>();
    ...
}
```
고애 객체 제거 기능은 영속성 컨텍스트를 플러시할 때 적용되므로 플러시 시점에서 DELETE SQL이 실행된다.

## 8.6 영속성 전이 + 고아 객체, 생명 주기
일반적으로 엔티티는 스스로 생명 주기를 관리하지만, 영속성 전이와 고아 객체 제거 기능을 활용하면 부모 엔티티가 자식 엔티티의 생명 주기를 관리할 수 있게 된다.
