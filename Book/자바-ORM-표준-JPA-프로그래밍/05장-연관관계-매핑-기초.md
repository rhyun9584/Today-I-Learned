# 05장 연관관계 매핑 기초

* [5.1 단방향 연관관계](#51-단방향-연관관계)
* [5.2 연관관계 사용](#52-연관관계-사용)
* [5.3 양방향 연관관계](#53-양방향-연관관계)
* [5.4 연관관계의 주인](#54-연관관계의-주인)
* [5.5 양방향 연관관계 저장](#55-양방향-연관관계-저장)
* [5.6 양방향 연관관계의 주의점](#56-양방향-연관관계의-주의점)
* [5.7 정리](#57-정리)

---

* **방향**: [단방향, 양방향]
    * 방향은 객체 관계에서만 존재하며 테이블은 항상 양방향
* **다중성**: [다대일(N:1), 일대다(1:N), 일대일(1:1), 대다대(N:M)]
* **연관관계의 주인**
    * 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야한다.

## 5.1 단방향 연관관계
참조를 통한 연관관계는 언제나 단방향.<br> 
참조를 통한 연관관계를 양방향으로 만드는 것은, 정확히는 서로 다른 단방향 관계 2개이다.
```java
@Entity
public class Member {
    ...

    // 연관관계 매핑
    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;

    ...
}
```
### 5.1.4 `@JoinColumn`
외래 키 매핑할 때 사용한다. <br>
엔티티에서는 객체를 참조하고, 테이블에서는 TEAM 테이블의 id인 `TEAM_ID`의 값을 가질수 있도록 활용한다.

`@JoinColumn` 어노테이션을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다.<br>
기본 전략: `{필드명}_{참조하는 테이블의 컬럼명}`<br>
위 예시의 경우에는 `team_TEAM_ID`를 사용한다.

## 5.2 연관관계 사용
JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.

### 5.2.5 연관된 엔티티 삭제
연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다.

## 5.3 양방향 연관관계
* 회원 → 팀 (Member.team)
* 팀 → 회원 (Team.members)

JPA는 List를 포함해서 Collection, Set, Map 같은 다양한 컬렉션을 지원한다.

데이터베이스 테이블은 외래 키 하나로 양방향으로 조회할 수 있다.
```java
@Entity
public class Team {
    ...

    @OneToMany(mappedBy="team")
    private List<Member> members = new ArrayList<>();

    ...
}
```
일대다 관계를 매핑하기 위해 `@OneToMany` 매핑 정보를 사용하는데, 이 때 `mappedBy`속성으로 반대쪽 매핑 필드 이름을 값으로 지정한다.

## 5.4 연관관계의 주인
엄밀하게는 객체에서 양방향 연관관계라는 것이 없다.

**객체 연관관계**는 단방향 2개의 연관관계를 갖는다.
* 회원 → 팀 연관관계 1개 (단방향)
* 팀 → 회원 연관관계 1개 (단방향)

**테이블 연관관계**는 양방향 1개의 연관관계를 갖는다.
* 회원 ↔ 팀 연관관계 1개 (양방향)

엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나인 상태가 된다. 따라서 객체와 테이블 간의 차이가 발생한다.

이런 차이로 인해 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이 것을 **연관관계의 주인**이라 한다.<br>
연관관계의 주인은 **외래 키를 갖는 곳**이 된다. 즉 다대일, 일대다 관계에서는 *다*의 위치에 놓인 곳에서 외래 키를 갖고 관리하게 된다. 즉, 회원과 팀의 관계에서는 `Member.team`이 연관관계의 주인이다.

## 5.5 양방향 연관관계 저장
양방향 연관관계는 연관관계의 주인이 외래 키를 관리한다. 따라서 주인이 아는 방향은 값을 설정하지 않아도 데이터베이스에 외래 키 값이 정상 입력된다.

## 5.6 양방향 연관관계의 주의점
### 5.6.1 순수한 객체까지 고려한 양방향 연관관계
객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 안전하다.

### 5.6.2 연관관계 편의 메소드
양쪽 모두 값을 넣어주는 과정에서 한 방향에만 값을 넣는 문제가 발생할 수 있다.
```java
public class Member {
    private Team team;

    public void setTeam(Team team) {
        this.team = team;
        team.getMembers().add(this);
    }
}
```
그 때, 예시와 같은 메소드 하나로 양방향 모두 설정할 수 있는데 이 메소드를 **연관관계 편의 메소드**라 한다.

### 5.6.3 연관관계 편의 메소드 작성 시 주의사항
```java
member1.setTeam(teamA);
member1.setTeam(teamB);
Member findMember = teamA.getMember(); // 여전히 member1이 조회된다.
```
위 예제를 보면 `member1`의 팀을 `teamA`에서 `teamB`로 변경하였으나, `teamA` → `member1` 방향의 연결이 삭제되지 않아 여전히 `teamA`의 회원 리스트에서 `member1`이 조회되는 문제가 발생하였다.

```java
public void setTeam(Team team) {
    if (this.team != null) {
        this.team.getMembers().remove(this);
    }

    this.team = team;
    team.getMembers().add(this);
}
```
다음과 같이 연관관계 편의 메소드를 수정하여, 기존 관계를 제거하는 코드를 추가하여 문제를 방지한다. 

## 5.7 정리
* 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료되었다.
* 단방향을 양방향으로 만들면 반대 방향으로 객체 그래프 탐색 기능이 추가된다.
* 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다.

추가로, 양방향 매핑 시에는 무한루프에 빠지지 않게 조심해야 한다. 예를 들어 `Member.toString()` 메소드를 사용할 때 `getTeam()`을 호출하고, 다시 `Team.toString()`에서 `getMember()`를 호출하면 무한루프에 빠질 수 있다.