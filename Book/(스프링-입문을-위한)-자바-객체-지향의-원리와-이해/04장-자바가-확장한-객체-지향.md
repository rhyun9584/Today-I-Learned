# 04장 자바가 확장한 객체 지향

* [`abstract` 키워드 - 추상 메소드와 추상 클래스](#abstract-키워드---추상-메소드와-추상-클래스)
* [생성자](#생성자)
* [클래스 생성 시의 실행 블록, `static` 블록](#클래스-생성-시의-실행-블록-static-블록)
* [`final` 키워드](#final-키워드)
* [`instanceof` 연산자](#instanceof-연산자)
* [`interface` 키워드와 `implements` 키워드](#interface-키워드와-implements-키워드)
* [`this` 키워드](#this-키워드)
* [`super` 키워드](#super-키워드)
* [추가](#추가)

## `abstract` 키워드 - 추상 메소드와 추상 클래스
직접 사용하지 않고 하위 클래스에 의해 상속되어 사용될 경우 추상 클래스로 만들어서 객체 생성을 막고 반드시 구현이 필요한 메소드를 지정한다.

* 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. 즉, `new`를 사용할 수 없다.
* 추상 메소드는 모든 하위 클래스에서 구현되어야 한다. 오버라이딩 강제.
* 추상 메소드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

## 생성자
생성자를 따로 정의하지 않는다면, 자바에서 인자를 받지않는 기본 생성자를 만들어준다.<br>
그러나 생성자를 하나라도 정의하면 기본 생성자를 만들어주지 않는다.

## 클래스 생성 시의 실행 블록, `static` 블록
클래스가 스태틱 영역에 배치될 때(~~프로그램이 로딩될 때?~~ 패키지 또는 클래스가 처음으로 사용될 때) 실행되는 코드블록이 있다.

```java
public class Animal {
    static {
        ...
    }
}
```
`static` 코드 블록에서는 `static` 속성과 메소드만 사용 가능하다.

**클래스가 처음 사용되는 때의 경우**
* 클래스의 정적 속성을 사용할 때
* 클래스의 정적 메소드를 사용할 때
* 클래스의 인스턴스를 만들 때

프로그램이 시작될 때가 아닌, **처음 사용될 때** 클래스를 스태틱 영역에 올리는 이유는 스태틱 영역이 메모리이기 때문이다. 메모리는 가능한 늦게 사용하고 빠르게 반환하는 것이 이득이다. 스태틱 영역에 한번 올리면 프로그램 종료까지 내릴 수 없기 때문에 가능한 늦게 올리는 것이다.

`static` 블록과 유사하게 인스턴스를 위한 인스턴스 블록도 존재한다. 아무런 표시 없이 `{}` 블록을 사용하게 되면 인스턴스를 생성할 때 마다 생성자보다 먼저 호출된다.

## `final` 키워드
### `final` 클래스
`public final class Animal {}`<br>
상속을 허용하지 않겠다는 의미.

### `final` 변수
값을 변경할 수 없는 <u>상수</u>가 됨.

### `final` 메소드
오버라이딩을 금지.

## `instanceof` 연산자
`instanceof` 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자.

하위 클래스의 객체 `instanceof` 상위 클래스 = `true`

객체 참조 변수의 타입이 아닌 실제 객체의 타입에 의해 처리함.
```java
Animal bird = new Bird();
bird instanceof Brid // true!
```
그러나 `instanceof` 연산자가 등장하는 코드는 LSP(리스코프 치환 원칙)을 어기는 코드에서 주로 나타난다.

## `interface` 키워드와 `implements` 키워드
인터페이스는 *`public` 추상 메소드*와 *`public` 정적 상수*만 가질 수 있다.

메소드에 `public`, `abstract` 속성에 `public`, `static`, `final`을 붙이지 않아도 자바가 자동으로 붙여준다.

## `this` 키워드
지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 **지역 변수**가 우선한다.

객체 변수와 이름이 같은 지역 변수가 있는 경우 객체 변수를 사용하려면 **`this`를 사용**한다.<br>
정적 변수와 이름이 같은 지역 변수가 있는 경우 정적 변수를 사용하려면 **클래스명을 사용**한다.

## `super` 키워드
바로 위 상위 클래스의 인스턴스를 지칭하는 키워드.<br>
`super.super` 같은 형태는 사용이 불가능하다.

## 추가
```java
class 펭귄 {
    void test() {
        ...
    }
}

public class Driver {
    public static void main(String[] args) {
        펭귄 뽀로로 = new 펭귄();

        뽀로로.test();
    }
}
```
위 코드를 실행했을 때, 디버그를 해보면 `뽀로로.test();`는 `펭귄.test()`의 형태로 나타난다.

객체 멤버 메소드는 객체 별로 다른 내용을 갖지 않는다. 따라서 객체 멤버 메소드를 클래스가 있는 스태틱 영역에 단 하나만 보유한다.<br>
그리고 일반적으로 객체 멤버 메소드에는 `this` 객체 참조 변수를 넘긴다.